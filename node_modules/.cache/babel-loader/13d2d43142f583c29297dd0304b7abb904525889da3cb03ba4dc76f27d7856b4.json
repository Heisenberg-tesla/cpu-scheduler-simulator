{"ast":null,"code":"export const sjf = processes => {\n  const processQueue = [...processes].map(p => ({\n    ...p\n  }));\n  const ganttChart = [];\n  const completedProcesses = [];\n  let currentTime = 0;\n  while (processQueue.length > 0) {\n    // Find all processes that have arrived by current time\n    const availableProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n    if (availableProcesses.length === 0) {\n      // No processes available, jump to next arrival time\n      currentTime = Math.min(...processQueue.map(p => p.arrivalTime));\n      continue;\n    }\n\n    // Find process with shortest burst time among available processes\n    const shortestJob = availableProcesses.reduce((prev, curr) => prev.burstTime < curr.burstTime ? prev : curr);\n\n    // Remove the process from queue\n    const processIndex = processQueue.findIndex(p => p.id === shortestJob.id);\n    processQueue.splice(processIndex, 1);\n\n    // Set start time if not already set (for response time)\n    shortestJob.startTime = currentTime;\n    shortestJob.responseTime = shortestJob.startTime - shortestJob.arrivalTime;\n\n    // Add to Gantt chart\n    ganttChart.push({\n      processId: shortestJob.id,\n      startTime: currentTime,\n      endTime: currentTime + shortestJob.burstTime,\n      color: shortestJob.color\n    });\n\n    // Update times\n    currentTime += shortestJob.burstTime;\n    shortestJob.completionTime = currentTime;\n    shortestJob.turnaroundTime = shortestJob.completionTime - shortestJob.arrivalTime;\n    shortestJob.waitingTime = shortestJob.turnaroundTime - shortestJob.burstTime;\n    completedProcesses.push(shortestJob);\n  }\n\n  // Calculate averages\n  const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n  const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n  const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n  return {\n    ganttChart,\n    processes: completedProcesses,\n    averageWaitingTime: avgWaitingTime,\n    averageTurnaroundTime: avgTurnaroundTime,\n    averageResponseTime: avgResponseTime\n  };\n};","map":{"version":3,"names":["sjf","processes","processQueue","map","p","ganttChart","completedProcesses","currentTime","length","availableProcesses","filter","arrivalTime","Math","min","shortestJob","reduce","prev","curr","burstTime","processIndex","findIndex","id","splice","startTime","responseTime","push","processId","endTime","color","completionTime","turnaroundTime","waitingTime","avgWaitingTime","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/sjf.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const sjf = (processes: Process[]): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ ...p }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n\n    while (processQueue.length > 0) {\n        // Find all processes that have arrived by current time\n        const availableProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n        if (availableProcesses.length === 0) {\n            // No processes available, jump to next arrival time\n            currentTime = Math.min(...processQueue.map(p => p.arrivalTime));\n            continue;\n        }\n\n        // Find process with shortest burst time among available processes\n        const shortestJob = availableProcesses.reduce((prev, curr) => \n            prev.burstTime < curr.burstTime ? prev : curr\n        );\n\n        // Remove the process from queue\n        const processIndex = processQueue.findIndex(p => p.id === shortestJob.id);\n        processQueue.splice(processIndex, 1);\n\n        // Set start time if not already set (for response time)\n        shortestJob.startTime = currentTime;\n        shortestJob.responseTime = shortestJob.startTime - shortestJob.arrivalTime;\n\n        // Add to Gantt chart\n        ganttChart.push({\n            processId: shortestJob.id,\n            startTime: currentTime,\n            endTime: currentTime + shortestJob.burstTime,\n            color: shortestJob.color\n        });\n\n        // Update times\n        currentTime += shortestJob.burstTime;\n        shortestJob.completionTime = currentTime;\n        shortestJob.turnaroundTime = shortestJob.completionTime - shortestJob.arrivalTime;\n        shortestJob.waitingTime = shortestJob.turnaroundTime - shortestJob.burstTime;\n\n        completedProcesses.push(shortestJob);\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"AAEA,OAAO,MAAMA,GAAG,GAAIC,SAAoB,IAAsB;EAC1D,MAAMC,YAAY,GAAG,CAAC,GAAGD,SAAS,CAAC,CAACE,GAAG,CAACC,CAAC,KAAK;IAAE,GAAGA;EAAE,CAAC,CAAC,CAAC;EACxD,MAAMC,UAA6B,GAAG,EAAE;EACxC,MAAMC,kBAA6B,GAAG,EAAE;EACxC,IAAIC,WAAW,GAAG,CAAC;EAEnB,OAAOL,YAAY,CAACM,MAAM,GAAG,CAAC,EAAE;IAC5B;IACA,MAAMC,kBAAkB,GAAGP,YAAY,CAACQ,MAAM,CAACN,CAAC,IAAIA,CAAC,CAACO,WAAW,IAAIJ,WAAW,CAAC;IAEjF,IAAIE,kBAAkB,CAACD,MAAM,KAAK,CAAC,EAAE;MACjC;MACAD,WAAW,GAAGK,IAAI,CAACC,GAAG,CAAC,GAAGX,YAAY,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACO,WAAW,CAAC,CAAC;MAC/D;IACJ;;IAEA;IACA,MAAMG,WAAW,GAAGL,kBAAkB,CAACM,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KACrDD,IAAI,CAACE,SAAS,GAAGD,IAAI,CAACC,SAAS,GAAGF,IAAI,GAAGC,IAC7C,CAAC;;IAED;IACA,MAAME,YAAY,GAAGjB,YAAY,CAACkB,SAAS,CAAChB,CAAC,IAAIA,CAAC,CAACiB,EAAE,KAAKP,WAAW,CAACO,EAAE,CAAC;IACzEnB,YAAY,CAACoB,MAAM,CAACH,YAAY,EAAE,CAAC,CAAC;;IAEpC;IACAL,WAAW,CAACS,SAAS,GAAGhB,WAAW;IACnCO,WAAW,CAACU,YAAY,GAAGV,WAAW,CAACS,SAAS,GAAGT,WAAW,CAACH,WAAW;;IAE1E;IACAN,UAAU,CAACoB,IAAI,CAAC;MACZC,SAAS,EAAEZ,WAAW,CAACO,EAAE;MACzBE,SAAS,EAAEhB,WAAW;MACtBoB,OAAO,EAAEpB,WAAW,GAAGO,WAAW,CAACI,SAAS;MAC5CU,KAAK,EAAEd,WAAW,CAACc;IACvB,CAAC,CAAC;;IAEF;IACArB,WAAW,IAAIO,WAAW,CAACI,SAAS;IACpCJ,WAAW,CAACe,cAAc,GAAGtB,WAAW;IACxCO,WAAW,CAACgB,cAAc,GAAGhB,WAAW,CAACe,cAAc,GAAGf,WAAW,CAACH,WAAW;IACjFG,WAAW,CAACiB,WAAW,GAAGjB,WAAW,CAACgB,cAAc,GAAGhB,WAAW,CAACI,SAAS;IAE5EZ,kBAAkB,CAACmB,IAAI,CAACX,WAAW,CAAC;EACxC;;EAEA;EACA,MAAMkB,cAAc,GAAG1B,kBAAkB,CAACS,MAAM,CAAC,CAACkB,GAAG,EAAE7B,CAAC,KAAK6B,GAAG,GAAG7B,CAAC,CAAC2B,WAAY,EAAE,CAAC,CAAC,GAAG9B,SAAS,CAACO,MAAM;EACxG,MAAM0B,iBAAiB,GAAG5B,kBAAkB,CAACS,MAAM,CAAC,CAACkB,GAAG,EAAE7B,CAAC,KAAK6B,GAAG,GAAG7B,CAAC,CAAC0B,cAAe,EAAE,CAAC,CAAC,GAAG7B,SAAS,CAACO,MAAM;EAC9G,MAAM2B,eAAe,GAAG7B,kBAAkB,CAACS,MAAM,CAAC,CAACkB,GAAG,EAAE7B,CAAC,KAAK6B,GAAG,GAAG7B,CAAC,CAACoB,YAAa,EAAE,CAAC,CAAC,GAAGvB,SAAS,CAACO,MAAM;EAE1G,OAAO;IACHH,UAAU;IACVJ,SAAS,EAAEK,kBAAkB;IAC7B8B,kBAAkB,EAAEJ,cAAc;IAClCK,qBAAqB,EAAEH,iBAAiB;IACxCI,mBAAmB,EAAEH;EACzB,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}