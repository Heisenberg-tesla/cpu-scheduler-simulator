{"ast":null,"code":"import _objectSpread from\"C:/Users/ayush/OneDrive/Desktop/Job Scheduler/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";export const fcfs=processes=>{// Sort processes by arrival time\nconst sortedProcesses=[...processes].sort((a,b)=>a.arrivalTime-b.arrivalTime);const ganttChart=[];let currentTime=0;// Process each job and store updated processes\nconst updatedProcesses=sortedProcesses.map(process=>{const p=_objectSpread(_objectSpread({},process),{},{startTime:0,completionTime:0,turnaroundTime:0,waitingTime:0,responseTime:0});// If there's a gap between current time and process arrival\nif(currentTime<p.arrivalTime){currentTime=p.arrivalTime;}// Set start time if not already set (for response time calculation)\np.startTime=currentTime;p.responseTime=p.startTime-p.arrivalTime;// Add to Gantt chart\nganttChart.push({processId:p.id,startTime:currentTime,endTime:currentTime+p.burstTime,color:p.color});// Update times\ncurrentTime+=p.burstTime;p.completionTime=currentTime;p.turnaroundTime=p.completionTime-p.arrivalTime;p.waitingTime=p.turnaroundTime-p.burstTime;return p;});// Calculate averages using updated processes\nconst avgWaitingTime=updatedProcesses.reduce((sum,p)=>sum+p.waitingTime,0)/processes.length;const avgTurnaroundTime=updatedProcesses.reduce((sum,p)=>sum+p.turnaroundTime,0)/processes.length;const avgResponseTime=updatedProcesses.reduce((sum,p)=>sum+p.responseTime,0)/processes.length;return{ganttChart,processes:updatedProcesses,averageWaitingTime:avgWaitingTime,averageTurnaroundTime:avgTurnaroundTime,averageResponseTime:avgResponseTime};};","map":{"version":3,"names":["fcfs","processes","sortedProcesses","sort","a","b","arrivalTime","ganttChart","currentTime","updatedProcesses","map","process","p","_objectSpread","startTime","completionTime","turnaroundTime","waitingTime","responseTime","push","processId","id","endTime","burstTime","color","avgWaitingTime","reduce","sum","length","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/fcfs.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const fcfs = (processes: Process[]): SchedulerResult => {\n    // Sort processes by arrival time\n    const sortedProcesses = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);\n    const ganttChart: GanttChartBlock[] = [];\n    let currentTime = 0;\n    \n    // Process each job and store updated processes\n    const updatedProcesses = sortedProcesses.map(process => {\n        const p = { \n            ...process,\n            startTime: 0,\n            completionTime: 0,\n            turnaroundTime: 0,\n            waitingTime: 0,\n            responseTime: 0\n        };\n        \n        // If there's a gap between current time and process arrival\n        if (currentTime < p.arrivalTime) {\n            currentTime = p.arrivalTime;\n        }\n        \n        // Set start time if not already set (for response time calculation)\n        p.startTime = currentTime;\n        p.responseTime = p.startTime - p.arrivalTime;\n        \n        // Add to Gantt chart\n        ganttChart.push({\n            processId: p.id,\n            startTime: currentTime,\n            endTime: currentTime + p.burstTime,\n            color: p.color\n        });\n        \n        // Update times\n        currentTime += p.burstTime;\n        p.completionTime = currentTime;\n        p.turnaroundTime = p.completionTime - p.arrivalTime;\n        p.waitingTime = p.turnaroundTime - p.burstTime;\n        \n        return p;\n    });\n    \n    // Calculate averages using updated processes\n    const avgWaitingTime = updatedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n    const avgTurnaroundTime = updatedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n    const avgResponseTime = updatedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n    \n    return {\n        ganttChart,\n        processes: updatedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"kIAEA,MAAO,MAAM,CAAAA,IAAI,CAAIC,SAAoB,EAAsB,CAC3D;AACA,KAAM,CAAAC,eAAe,CAAG,CAAC,GAAGD,SAAS,CAAC,CAACE,IAAI,CAAC,CAACC,CAAC,CAAEC,CAAC,GAAKD,CAAC,CAACE,WAAW,CAAGD,CAAC,CAACC,WAAW,CAAC,CACpF,KAAM,CAAAC,UAA6B,CAAG,EAAE,CACxC,GAAI,CAAAC,WAAW,CAAG,CAAC,CAEnB;AACA,KAAM,CAAAC,gBAAgB,CAAGP,eAAe,CAACQ,GAAG,CAACC,OAAO,EAAI,CACpD,KAAM,CAAAC,CAAC,CAAAC,aAAA,CAAAA,aAAA,IACAF,OAAO,MACVG,SAAS,CAAE,CAAC,CACZC,cAAc,CAAE,CAAC,CACjBC,cAAc,CAAE,CAAC,CACjBC,WAAW,CAAE,CAAC,CACdC,YAAY,CAAE,CAAC,EAClB,CAED;AACA,GAAIV,WAAW,CAAGI,CAAC,CAACN,WAAW,CAAE,CAC7BE,WAAW,CAAGI,CAAC,CAACN,WAAW,CAC/B,CAEA;AACAM,CAAC,CAACE,SAAS,CAAGN,WAAW,CACzBI,CAAC,CAACM,YAAY,CAAGN,CAAC,CAACE,SAAS,CAAGF,CAAC,CAACN,WAAW,CAE5C;AACAC,UAAU,CAACY,IAAI,CAAC,CACZC,SAAS,CAAER,CAAC,CAACS,EAAE,CACfP,SAAS,CAAEN,WAAW,CACtBc,OAAO,CAAEd,WAAW,CAAGI,CAAC,CAACW,SAAS,CAClCC,KAAK,CAAEZ,CAAC,CAACY,KACb,CAAC,CAAC,CAEF;AACAhB,WAAW,EAAII,CAAC,CAACW,SAAS,CAC1BX,CAAC,CAACG,cAAc,CAAGP,WAAW,CAC9BI,CAAC,CAACI,cAAc,CAAGJ,CAAC,CAACG,cAAc,CAAGH,CAAC,CAACN,WAAW,CACnDM,CAAC,CAACK,WAAW,CAAGL,CAAC,CAACI,cAAc,CAAGJ,CAAC,CAACW,SAAS,CAE9C,MAAO,CAAAX,CAAC,CACZ,CAAC,CAAC,CAEF;AACA,KAAM,CAAAa,cAAc,CAAGhB,gBAAgB,CAACiB,MAAM,CAAC,CAACC,GAAG,CAAEf,CAAC,GAAKe,GAAG,CAAGf,CAAC,CAACK,WAAW,CAAE,CAAC,CAAC,CAAGhB,SAAS,CAAC2B,MAAM,CACrG,KAAM,CAAAC,iBAAiB,CAAGpB,gBAAgB,CAACiB,MAAM,CAAC,CAACC,GAAG,CAAEf,CAAC,GAAKe,GAAG,CAAGf,CAAC,CAACI,cAAc,CAAE,CAAC,CAAC,CAAGf,SAAS,CAAC2B,MAAM,CAC3G,KAAM,CAAAE,eAAe,CAAGrB,gBAAgB,CAACiB,MAAM,CAAC,CAACC,GAAG,CAAEf,CAAC,GAAKe,GAAG,CAAGf,CAAC,CAACM,YAAY,CAAE,CAAC,CAAC,CAAGjB,SAAS,CAAC2B,MAAM,CAEvG,MAAO,CACHrB,UAAU,CACVN,SAAS,CAAEQ,gBAAgB,CAC3BsB,kBAAkB,CAAEN,cAAc,CAClCO,qBAAqB,CAAEH,iBAAiB,CACxCI,mBAAmB,CAAEH,eACzB,CAAC,CACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}