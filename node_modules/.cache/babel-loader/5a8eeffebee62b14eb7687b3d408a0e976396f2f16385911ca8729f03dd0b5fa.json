{"ast":null,"code":"export const roundRobin = (processes, timeQuantum) => {\n  const processQueue = [...processes].map(p => ({\n    ...p,\n    remainingTime: p.burstTime,\n    startTime: undefined\n  }));\n  const ganttChart = [];\n  const completedProcesses = [];\n  let currentTime = 0;\n  let readyQueue = [];\n  while (processQueue.length > 0 || readyQueue.length > 0) {\n    // Move arrived processes to ready queue\n    const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n    readyQueue.push(...newlyArrived);\n    processQueue.splice(0, newlyArrived.length);\n    if (readyQueue.length === 0) {\n      // No processes in ready queue, jump to next arrival\n      if (processQueue.length > 0) {\n        currentTime = Math.min(...processQueue.map(p => p.arrivalTime));\n        continue;\n      }\n      break;\n    }\n\n    // Get next process from ready queue\n    const currentProcess = readyQueue.shift();\n\n    // Set start time if first execution\n    if (currentProcess.startTime === undefined) {\n      currentProcess.startTime = currentTime;\n      currentProcess.responseTime = currentTime - currentProcess.arrivalTime;\n    }\n\n    // Calculate execution time for this quantum\n    const executionTime = Math.min(timeQuantum, currentProcess.remainingTime);\n\n    // Add to Gantt chart\n    ganttChart.push({\n      processId: currentProcess.id,\n      startTime: currentTime,\n      endTime: currentTime + executionTime,\n      color: currentProcess.color\n    });\n\n    // Update remaining time and current time\n    currentProcess.remainingTime -= executionTime;\n    currentTime += executionTime;\n\n    // Check if process is completed\n    if (currentProcess.remainingTime === 0) {\n      currentProcess.completionTime = currentTime;\n      currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;\n      currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;\n      completedProcesses.push(currentProcess);\n    } else {\n      // Move arrived processes to ready queue before re-adding current process\n      const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n      readyQueue.push(...newlyArrived);\n      processQueue.splice(0, newlyArrived.length);\n\n      // Add process back to ready queue\n      readyQueue.push(currentProcess);\n    }\n  }\n\n  // Calculate averages\n  const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n  const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n  const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n  return {\n    ganttChart,\n    processes: completedProcesses,\n    averageWaitingTime: avgWaitingTime,\n    averageTurnaroundTime: avgTurnaroundTime,\n    averageResponseTime: avgResponseTime\n  };\n};","map":{"version":3,"names":["roundRobin","processes","timeQuantum","processQueue","map","p","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","readyQueue","length","newlyArrived","filter","arrivalTime","push","splice","Math","min","currentProcess","shift","responseTime","executionTime","processId","id","endTime","color","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/roundRobin.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const roundRobin = (processes: Process[], timeQuantum: number): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let readyQueue: Process[] = [];\n\n    while (processQueue.length > 0 || readyQueue.length > 0) {\n        // Move arrived processes to ready queue\n        const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n        readyQueue.push(...newlyArrived);\n        processQueue.splice(0, newlyArrived.length);\n\n        if (readyQueue.length === 0) {\n            // No processes in ready queue, jump to next arrival\n            if (processQueue.length > 0) {\n                currentTime = Math.min(...processQueue.map(p => p.arrivalTime));\n                continue;\n            }\n            break;\n        }\n\n        // Get next process from ready queue\n        const currentProcess = readyQueue.shift()!;\n\n        // Set start time if first execution\n        if (currentProcess.startTime === undefined) {\n            currentProcess.startTime = currentTime;\n            currentProcess.responseTime = currentTime - currentProcess.arrivalTime;\n        }\n\n        // Calculate execution time for this quantum\n        const executionTime = Math.min(timeQuantum, currentProcess.remainingTime!);\n\n        // Add to Gantt chart\n        ganttChart.push({\n            processId: currentProcess.id,\n            startTime: currentTime,\n            endTime: currentTime + executionTime,\n            color: currentProcess.color\n        });\n\n        // Update remaining time and current time\n        currentProcess.remainingTime! -= executionTime;\n        currentTime += executionTime;\n\n        // Check if process is completed\n        if (currentProcess.remainingTime === 0) {\n            currentProcess.completionTime = currentTime;\n            currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;\n            currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;\n            completedProcesses.push(currentProcess);\n        } else {\n            // Move arrived processes to ready queue before re-adding current process\n            const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n            readyQueue.push(...newlyArrived);\n            processQueue.splice(0, newlyArrived.length);\n            \n            // Add process back to ready queue\n            readyQueue.push(currentProcess);\n        }\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}