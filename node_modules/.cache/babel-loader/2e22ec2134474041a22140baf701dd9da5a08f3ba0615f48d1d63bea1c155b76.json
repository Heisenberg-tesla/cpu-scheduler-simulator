{"ast":null,"code":"export const fcfs = processes => {\n  // Sort processes by arrival time\n  const sortedProcesses = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);\n  const ganttChart = [];\n  let currentTime = 0;\n\n  // Process each job and store updated processes\n  const updatedProcesses = sortedProcesses.map(process => {\n    const p = {\n      ...process,\n      startTime: 0,\n      completionTime: 0,\n      turnaroundTime: 0,\n      waitingTime: 0,\n      responseTime: 0\n    };\n\n    // If there's a gap between current time and process arrival\n    if (currentTime < p.arrivalTime) {\n      currentTime = p.arrivalTime;\n    }\n\n    // Set start time if not already set (for response time calculation)\n    p.startTime = currentTime;\n    p.responseTime = p.startTime - p.arrivalTime;\n\n    // Add to Gantt chart\n    ganttChart.push({\n      processId: p.id,\n      startTime: currentTime,\n      endTime: currentTime + p.burstTime,\n      color: p.color\n    });\n\n    // Update times\n    currentTime += p.burstTime;\n    p.completionTime = currentTime;\n    p.turnaroundTime = p.completionTime - p.arrivalTime;\n    p.waitingTime = p.turnaroundTime - p.burstTime;\n    return p;\n  });\n\n  // Calculate averages using updated processes\n  const avgWaitingTime = updatedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n  const avgTurnaroundTime = updatedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n  const avgResponseTime = updatedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n  return {\n    ganttChart,\n    processes: updatedProcesses,\n    averageWaitingTime: avgWaitingTime,\n    averageTurnaroundTime: avgTurnaroundTime,\n    averageResponseTime: avgResponseTime\n  };\n};","map":{"version":3,"names":["fcfs","processes","sortedProcesses","sort","a","b","arrivalTime","ganttChart","currentTime","updatedProcesses","map","process","p","startTime","completionTime","turnaroundTime","waitingTime","responseTime","push","processId","id","endTime","burstTime","color","avgWaitingTime","reduce","sum","length","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/fcfs.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const fcfs = (processes: Process[]): SchedulerResult => {\n    // Sort processes by arrival time\n    const sortedProcesses = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);\n    const ganttChart: GanttChartBlock[] = [];\n    let currentTime = 0;\n    \n    // Process each job and store updated processes\n    const updatedProcesses = sortedProcesses.map(process => {\n        const p = { \n            ...process,\n            startTime: 0,\n            completionTime: 0,\n            turnaroundTime: 0,\n            waitingTime: 0,\n            responseTime: 0\n        };\n        \n        // If there's a gap between current time and process arrival\n        if (currentTime < p.arrivalTime) {\n            currentTime = p.arrivalTime;\n        }\n        \n        // Set start time if not already set (for response time calculation)\n        p.startTime = currentTime;\n        p.responseTime = p.startTime - p.arrivalTime;\n        \n        // Add to Gantt chart\n        ganttChart.push({\n            processId: p.id,\n            startTime: currentTime,\n            endTime: currentTime + p.burstTime,\n            color: p.color\n        });\n        \n        // Update times\n        currentTime += p.burstTime;\n        p.completionTime = currentTime;\n        p.turnaroundTime = p.completionTime - p.arrivalTime;\n        p.waitingTime = p.turnaroundTime - p.burstTime;\n        \n        return p;\n    });\n    \n    // Calculate averages using updated processes\n    const avgWaitingTime = updatedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n    const avgTurnaroundTime = updatedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n    const avgResponseTime = updatedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n    \n    return {\n        ganttChart,\n        processes: updatedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"AAEA,OAAO,MAAMA,IAAI,GAAIC,SAAoB,IAAsB;EAC3D;EACA,MAAMC,eAAe,GAAG,CAAC,GAAGD,SAAS,CAAC,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,WAAW,GAAGD,CAAC,CAACC,WAAW,CAAC;EACpF,MAAMC,UAA6B,GAAG,EAAE;EACxC,IAAIC,WAAW,GAAG,CAAC;;EAEnB;EACA,MAAMC,gBAAgB,GAAGP,eAAe,CAACQ,GAAG,CAACC,OAAO,IAAI;IACpD,MAAMC,CAAC,GAAG;MACN,GAAGD,OAAO;MACVE,SAAS,EAAE,CAAC;MACZC,cAAc,EAAE,CAAC;MACjBC,cAAc,EAAE,CAAC;MACjBC,WAAW,EAAE,CAAC;MACdC,YAAY,EAAE;IAClB,CAAC;;IAED;IACA,IAAIT,WAAW,GAAGI,CAAC,CAACN,WAAW,EAAE;MAC7BE,WAAW,GAAGI,CAAC,CAACN,WAAW;IAC/B;;IAEA;IACAM,CAAC,CAACC,SAAS,GAAGL,WAAW;IACzBI,CAAC,CAACK,YAAY,GAAGL,CAAC,CAACC,SAAS,GAAGD,CAAC,CAACN,WAAW;;IAE5C;IACAC,UAAU,CAACW,IAAI,CAAC;MACZC,SAAS,EAAEP,CAAC,CAACQ,EAAE;MACfP,SAAS,EAAEL,WAAW;MACtBa,OAAO,EAAEb,WAAW,GAAGI,CAAC,CAACU,SAAS;MAClCC,KAAK,EAAEX,CAAC,CAACW;IACb,CAAC,CAAC;;IAEF;IACAf,WAAW,IAAII,CAAC,CAACU,SAAS;IAC1BV,CAAC,CAACE,cAAc,GAAGN,WAAW;IAC9BI,CAAC,CAACG,cAAc,GAAGH,CAAC,CAACE,cAAc,GAAGF,CAAC,CAACN,WAAW;IACnDM,CAAC,CAACI,WAAW,GAAGJ,CAAC,CAACG,cAAc,GAAGH,CAAC,CAACU,SAAS;IAE9C,OAAOV,CAAC;EACZ,CAAC,CAAC;;EAEF;EACA,MAAMY,cAAc,GAAGf,gBAAgB,CAACgB,MAAM,CAAC,CAACC,GAAG,EAAEd,CAAC,KAAKc,GAAG,GAAGd,CAAC,CAACI,WAAW,EAAE,CAAC,CAAC,GAAGf,SAAS,CAAC0B,MAAM;EACrG,MAAMC,iBAAiB,GAAGnB,gBAAgB,CAACgB,MAAM,CAAC,CAACC,GAAG,EAAEd,CAAC,KAAKc,GAAG,GAAGd,CAAC,CAACG,cAAc,EAAE,CAAC,CAAC,GAAGd,SAAS,CAAC0B,MAAM;EAC3G,MAAME,eAAe,GAAGpB,gBAAgB,CAACgB,MAAM,CAAC,CAACC,GAAG,EAAEd,CAAC,KAAKc,GAAG,GAAGd,CAAC,CAACK,YAAY,EAAE,CAAC,CAAC,GAAGhB,SAAS,CAAC0B,MAAM;EAEvG,OAAO;IACHpB,UAAU;IACVN,SAAS,EAAEQ,gBAAgB;IAC3BqB,kBAAkB,EAAEN,cAAc;IAClCO,qBAAqB,EAAEH,iBAAiB;IACxCI,mBAAmB,EAAEH;EACzB,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}