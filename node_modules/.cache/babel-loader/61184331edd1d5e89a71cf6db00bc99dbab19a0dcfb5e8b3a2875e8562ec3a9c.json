{"ast":null,"code":"export const priority = (processes, isPreemptive) => {\n  const processQueue = [...processes].map(p => ({\n    ...p,\n    remainingTime: p.burstTime,\n    startTime: undefined\n  }));\n  const ganttChart = [];\n  const completedProcesses = [];\n  let currentTime = 0;\n  let currentProcess = null;\n  let lastProcessId = null;\n  while (processQueue.length > 0 || currentProcess) {\n    // Get available processes\n    const availableProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n    // Find highest priority process\n    let highestPriorityProcess = currentProcess;\n    for (const process of availableProcesses) {\n      if (!highestPriorityProcess || process.priority < highestPriorityProcess.priority || process.priority === highestPriorityProcess.priority && process.arrivalTime < highestPriorityProcess.arrivalTime) {\n        if (isPreemptive || !currentProcess) {\n          highestPriorityProcess = process;\n        }\n      }\n    }\n\n    // Process context switch if needed\n    if (highestPriorityProcess && highestPriorityProcess.id !== lastProcessId) {\n      if (lastProcessId !== null) {\n        // Add previous process block to Gantt chart\n        const lastGanttBlock = ganttChart[ganttChart.length - 1];\n        if (lastGanttBlock) {\n          lastGanttBlock.endTime = currentTime;\n        }\n      }\n\n      // Start new process block\n      if (highestPriorityProcess.startTime === undefined) {\n        highestPriorityProcess.startTime = currentTime;\n        highestPriorityProcess.responseTime = currentTime - highestPriorityProcess.arrivalTime;\n      }\n      ganttChart.push({\n        processId: highestPriorityProcess.id,\n        startTime: currentTime,\n        endTime: currentTime + 1,\n        // Will be updated in next iteration\n        color: highestPriorityProcess.color\n      });\n    }\n\n    // Update current process and time\n    if (highestPriorityProcess) {\n      highestPriorityProcess.remainingTime--;\n      lastProcessId = highestPriorityProcess.id;\n\n      // Check if process is completed\n      if (highestPriorityProcess.remainingTime === 0) {\n        const processIndex = processQueue.findIndex(p => p.id === highestPriorityProcess.id);\n        if (processIndex !== -1) {\n          processQueue.splice(processIndex, 1);\n        }\n        highestPriorityProcess.completionTime = currentTime + 1;\n        highestPriorityProcess.turnaroundTime = highestPriorityProcess.completionTime - highestPriorityProcess.arrivalTime;\n        highestPriorityProcess.waitingTime = highestPriorityProcess.turnaroundTime - highestPriorityProcess.burstTime;\n        completedProcesses.push(highestPriorityProcess);\n        currentProcess = null;\n      } else {\n        currentProcess = highestPriorityProcess;\n      }\n    }\n    currentTime++;\n  }\n\n  // Update last Gantt chart block\n  if (ganttChart.length > 0) {\n    ganttChart[ganttChart.length - 1].endTime = currentTime;\n  }\n\n  // Calculate averages\n  const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n  const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n  const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n  return {\n    ganttChart,\n    processes: completedProcesses,\n    averageWaitingTime: avgWaitingTime,\n    averageTurnaroundTime: avgTurnaroundTime,\n    averageResponseTime: avgResponseTime\n  };\n};","map":{"version":3,"names":["priority","processes","isPreemptive","processQueue","map","p","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","currentProcess","lastProcessId","length","availableProcesses","filter","arrivalTime","highestPriorityProcess","process","id","lastGanttBlock","endTime","responseTime","push","processId","color","processIndex","findIndex","splice","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/priority.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const priority = (processes: Process[], isPreemptive: boolean): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let currentProcess: Process | null = null;\n    let lastProcessId: string | null = null;\n\n    while (processQueue.length > 0 || currentProcess) {\n        // Get available processes\n        const availableProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n        // Find highest priority process\n        let highestPriorityProcess: Process | null = currentProcess;\n        for (const process of availableProcesses) {\n            if (!highestPriorityProcess || \n                (process.priority! < highestPriorityProcess.priority!) || \n                (process.priority === highestPriorityProcess.priority && \n                 process.arrivalTime < highestPriorityProcess.arrivalTime)) {\n                if (isPreemptive || !currentProcess) {\n                    highestPriorityProcess = process;\n                }\n            }\n        }\n\n        // Process context switch if needed\n        if (highestPriorityProcess && highestPriorityProcess.id !== lastProcessId) {\n            if (lastProcessId !== null) {\n                // Add previous process block to Gantt chart\n                const lastGanttBlock = ganttChart[ganttChart.length - 1];\n                if (lastGanttBlock) {\n                    lastGanttBlock.endTime = currentTime;\n                }\n            }\n\n            // Start new process block\n            if (highestPriorityProcess.startTime === undefined) {\n                highestPriorityProcess.startTime = currentTime;\n                highestPriorityProcess.responseTime = currentTime - highestPriorityProcess.arrivalTime;\n            }\n\n            ganttChart.push({\n                processId: highestPriorityProcess.id,\n                startTime: currentTime,\n                endTime: currentTime + 1, // Will be updated in next iteration\n                color: highestPriorityProcess.color\n            });\n        }\n\n        // Update current process and time\n        if (highestPriorityProcess) {\n            highestPriorityProcess.remainingTime!--;\n            lastProcessId = highestPriorityProcess.id;\n\n            // Check if process is completed\n            if (highestPriorityProcess.remainingTime === 0) {\n                const processIndex = processQueue.findIndex(p => p.id === highestPriorityProcess!.id);\n                if (processIndex !== -1) {\n                    processQueue.splice(processIndex, 1);\n                }\n\n                highestPriorityProcess.completionTime = currentTime + 1;\n                highestPriorityProcess.turnaroundTime = highestPriorityProcess.completionTime - highestPriorityProcess.arrivalTime;\n                highestPriorityProcess.waitingTime = highestPriorityProcess.turnaroundTime - highestPriorityProcess.burstTime;\n                completedProcesses.push(highestPriorityProcess);\n                currentProcess = null;\n            } else {\n                currentProcess = highestPriorityProcess;\n            }\n        }\n\n        currentTime++;\n    }\n\n    // Update last Gantt chart block\n    if (ganttChart.length > 0) {\n        ganttChart[ganttChart.length - 1].endTime = currentTime;\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}