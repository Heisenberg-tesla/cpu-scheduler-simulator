{"ast":null,"code":"import _objectSpread from\"C:/Users/ayush/OneDrive/Desktop/Job Scheduler/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";export const srtf=processes=>{const processQueue=[...processes].map(p=>_objectSpread(_objectSpread({},p),{},{remainingTime:p.burstTime,startTime:undefined}));const ganttChart=[];const completedProcesses=[];let currentTime=0;let currentProcess=null;let lastProcessId=null;while(processQueue.length>0||currentProcess){// Add newly arrived processes\nconst arrivedProcesses=processQueue.filter(p=>p.arrivalTime<=currentTime);// Find process with shortest remaining time\nlet shortestJob=currentProcess;for(const process of arrivedProcesses){if(!shortestJob||process.remainingTime<shortestJob.remainingTime){shortestJob=process;}}// Process context switch if needed\nif(shortestJob&&shortestJob.id!==lastProcessId){if(lastProcessId!==null){// Add previous process block to Gantt chart\nconst lastGanttBlock=ganttChart[ganttChart.length-1];if(lastGanttBlock){lastGanttBlock.endTime=currentTime;}}// Start new process block\nif(shortestJob.startTime===undefined){shortestJob.startTime=currentTime;shortestJob.responseTime=currentTime-shortestJob.arrivalTime;}ganttChart.push({processId:shortestJob.id,startTime:currentTime,endTime:currentTime+1,// Will be updated in next iteration\ncolor:shortestJob.color});}// Update current process and time\nif(shortestJob){shortestJob.remainingTime--;lastProcessId=shortestJob.id;// Check if process is completed\nif(shortestJob.remainingTime===0){const processIndex=processQueue.findIndex(p=>p.id===shortestJob.id);if(processIndex!==-1){processQueue.splice(processIndex,1);}shortestJob.completionTime=currentTime+1;shortestJob.turnaroundTime=shortestJob.completionTime-shortestJob.arrivalTime;shortestJob.waitingTime=shortestJob.turnaroundTime-shortestJob.burstTime;completedProcesses.push(shortestJob);currentProcess=null;}else{currentProcess=shortestJob;}}currentTime++;}// Update last Gantt chart block\nif(ganttChart.length>0){ganttChart[ganttChart.length-1].endTime=currentTime;}// Calculate averages\nconst avgWaitingTime=completedProcesses.reduce((sum,p)=>sum+p.waitingTime,0)/processes.length;const avgTurnaroundTime=completedProcesses.reduce((sum,p)=>sum+p.turnaroundTime,0)/processes.length;const avgResponseTime=completedProcesses.reduce((sum,p)=>sum+p.responseTime,0)/processes.length;return{ganttChart,processes:completedProcesses,averageWaitingTime:avgWaitingTime,averageTurnaroundTime:avgTurnaroundTime,averageResponseTime:avgResponseTime};};","map":{"version":3,"names":["srtf","processes","processQueue","map","p","_objectSpread","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","currentProcess","lastProcessId","length","arrivedProcesses","filter","arrivalTime","shortestJob","process","id","lastGanttBlock","endTime","responseTime","push","processId","color","processIndex","findIndex","splice","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/srtf.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const srtf = (processes: Process[]): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let currentProcess: Process | null = null;\n    let lastProcessId: string | null = null;\n\n    while (processQueue.length > 0 || currentProcess) {\n        // Add newly arrived processes\n        const arrivedProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n        // Find process with shortest remaining time\n        let shortestJob: Process | null = currentProcess;\n        for (const process of arrivedProcesses) {\n            if (!shortestJob || process.remainingTime! < shortestJob.remainingTime!) {\n                shortestJob = process;\n            }\n        }\n\n        // Process context switch if needed\n        if (shortestJob && shortestJob.id !== lastProcessId) {\n            if (lastProcessId !== null) {\n                // Add previous process block to Gantt chart\n                const lastGanttBlock = ganttChart[ganttChart.length - 1];\n                if (lastGanttBlock) {\n                    lastGanttBlock.endTime = currentTime;\n                }\n            }\n\n            // Start new process block\n            if (shortestJob.startTime === undefined) {\n                shortestJob.startTime = currentTime;\n                shortestJob.responseTime = currentTime - shortestJob.arrivalTime;\n            }\n\n            ganttChart.push({\n                processId: shortestJob.id,\n                startTime: currentTime,\n                endTime: currentTime + 1, // Will be updated in next iteration\n                color: shortestJob.color\n            });\n        }\n\n        // Update current process and time\n        if (shortestJob) {\n            shortestJob.remainingTime!--;\n            lastProcessId = shortestJob.id;\n\n            // Check if process is completed\n            if (shortestJob.remainingTime === 0) {\n                const processIndex = processQueue.findIndex(p => p.id === shortestJob!.id);\n                if (processIndex !== -1) {\n                    processQueue.splice(processIndex, 1);\n                }\n\n                shortestJob.completionTime = currentTime + 1;\n                shortestJob.turnaroundTime = shortestJob.completionTime - shortestJob.arrivalTime;\n                shortestJob.waitingTime = shortestJob.turnaroundTime - shortestJob.burstTime;\n                completedProcesses.push(shortestJob);\n                currentProcess = null;\n            } else {\n                currentProcess = shortestJob;\n            }\n        }\n\n        currentTime++;\n    }\n\n    // Update last Gantt chart block\n    if (ganttChart.length > 0) {\n        ganttChart[ganttChart.length - 1].endTime = currentTime;\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"kIAEA,MAAO,MAAM,CAAAA,IAAI,CAAIC,SAAoB,EAAsB,CAC3D,KAAM,CAAAC,YAAY,CAAG,CAAC,GAAGD,SAAS,CAAC,CAACE,GAAG,CAACC,CAAC,EAAAC,aAAA,CAAAA,aAAA,IAClCD,CAAC,MACJE,aAAa,CAAEF,CAAC,CAACG,SAAS,CAC1BC,SAAS,CAAEC,SAAS,EACtB,CAAC,CACH,KAAM,CAAAC,UAA6B,CAAG,EAAE,CACxC,KAAM,CAAAC,kBAA6B,CAAG,EAAE,CACxC,GAAI,CAAAC,WAAW,CAAG,CAAC,CACnB,GAAI,CAAAC,cAA8B,CAAG,IAAI,CACzC,GAAI,CAAAC,aAA4B,CAAG,IAAI,CAEvC,MAAOZ,YAAY,CAACa,MAAM,CAAG,CAAC,EAAIF,cAAc,CAAE,CAC9C;AACA,KAAM,CAAAG,gBAAgB,CAAGd,YAAY,CAACe,MAAM,CAACb,CAAC,EAAIA,CAAC,CAACc,WAAW,EAAIN,WAAW,CAAC,CAE/E;AACA,GAAI,CAAAO,WAA2B,CAAGN,cAAc,CAChD,IAAK,KAAM,CAAAO,OAAO,GAAI,CAAAJ,gBAAgB,CAAE,CACpC,GAAI,CAACG,WAAW,EAAIC,OAAO,CAACd,aAAa,CAAIa,WAAW,CAACb,aAAc,CAAE,CACrEa,WAAW,CAAGC,OAAO,CACzB,CACJ,CAEA;AACA,GAAID,WAAW,EAAIA,WAAW,CAACE,EAAE,GAAKP,aAAa,CAAE,CACjD,GAAIA,aAAa,GAAK,IAAI,CAAE,CACxB;AACA,KAAM,CAAAQ,cAAc,CAAGZ,UAAU,CAACA,UAAU,CAACK,MAAM,CAAG,CAAC,CAAC,CACxD,GAAIO,cAAc,CAAE,CAChBA,cAAc,CAACC,OAAO,CAAGX,WAAW,CACxC,CACJ,CAEA;AACA,GAAIO,WAAW,CAACX,SAAS,GAAKC,SAAS,CAAE,CACrCU,WAAW,CAACX,SAAS,CAAGI,WAAW,CACnCO,WAAW,CAACK,YAAY,CAAGZ,WAAW,CAAGO,WAAW,CAACD,WAAW,CACpE,CAEAR,UAAU,CAACe,IAAI,CAAC,CACZC,SAAS,CAAEP,WAAW,CAACE,EAAE,CACzBb,SAAS,CAAEI,WAAW,CACtBW,OAAO,CAAEX,WAAW,CAAG,CAAC,CAAE;AAC1Be,KAAK,CAAER,WAAW,CAACQ,KACvB,CAAC,CAAC,CACN,CAEA;AACA,GAAIR,WAAW,CAAE,CACbA,WAAW,CAACb,aAAa,EAAG,CAC5BQ,aAAa,CAAGK,WAAW,CAACE,EAAE,CAE9B;AACA,GAAIF,WAAW,CAACb,aAAa,GAAK,CAAC,CAAE,CACjC,KAAM,CAAAsB,YAAY,CAAG1B,YAAY,CAAC2B,SAAS,CAACzB,CAAC,EAAIA,CAAC,CAACiB,EAAE,GAAKF,WAAW,CAAEE,EAAE,CAAC,CAC1E,GAAIO,YAAY,GAAK,CAAC,CAAC,CAAE,CACrB1B,YAAY,CAAC4B,MAAM,CAACF,YAAY,CAAE,CAAC,CAAC,CACxC,CAEAT,WAAW,CAACY,cAAc,CAAGnB,WAAW,CAAG,CAAC,CAC5CO,WAAW,CAACa,cAAc,CAAGb,WAAW,CAACY,cAAc,CAAGZ,WAAW,CAACD,WAAW,CACjFC,WAAW,CAACc,WAAW,CAAGd,WAAW,CAACa,cAAc,CAAGb,WAAW,CAACZ,SAAS,CAC5EI,kBAAkB,CAACc,IAAI,CAACN,WAAW,CAAC,CACpCN,cAAc,CAAG,IAAI,CACzB,CAAC,IAAM,CACHA,cAAc,CAAGM,WAAW,CAChC,CACJ,CAEAP,WAAW,EAAE,CACjB,CAEA;AACA,GAAIF,UAAU,CAACK,MAAM,CAAG,CAAC,CAAE,CACvBL,UAAU,CAACA,UAAU,CAACK,MAAM,CAAG,CAAC,CAAC,CAACQ,OAAO,CAAGX,WAAW,CAC3D,CAEA;AACA,KAAM,CAAAsB,cAAc,CAAGvB,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAAC6B,WAAY,CAAE,CAAC,CAAC,CAAGhC,SAAS,CAACc,MAAM,CACxG,KAAM,CAAAsB,iBAAiB,CAAG1B,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAAC4B,cAAe,CAAE,CAAC,CAAC,CAAG/B,SAAS,CAACc,MAAM,CAC9G,KAAM,CAAAuB,eAAe,CAAG3B,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAACoB,YAAa,CAAE,CAAC,CAAC,CAAGvB,SAAS,CAACc,MAAM,CAE1G,MAAO,CACHL,UAAU,CACVT,SAAS,CAAEU,kBAAkB,CAC7B4B,kBAAkB,CAAEL,cAAc,CAClCM,qBAAqB,CAAEH,iBAAiB,CACxCI,mBAAmB,CAAEH,eACzB,CAAC,CACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}