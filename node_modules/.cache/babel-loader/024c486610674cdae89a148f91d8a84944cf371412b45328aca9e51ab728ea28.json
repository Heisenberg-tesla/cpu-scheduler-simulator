{"ast":null,"code":"import _objectSpread from\"C:/Users/ayush/OneDrive/Desktop/Job Scheduler/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";export const roundRobin=(processes,timeQuantum)=>{const processQueue=[...processes].map(p=>_objectSpread(_objectSpread({},p),{},{remainingTime:p.burstTime,startTime:undefined}));const ganttChart=[];const completedProcesses=[];let currentTime=0;let readyQueue=[];while(processQueue.length>0||readyQueue.length>0){// Move arrived processes to ready queue\nconst newlyArrived=processQueue.filter(p=>p.arrivalTime<=currentTime);readyQueue.push(...newlyArrived);processQueue.splice(0,newlyArrived.length);if(readyQueue.length===0){// No processes in ready queue, jump to next arrival\nif(processQueue.length>0){currentTime=Math.min(...processQueue.map(p=>p.arrivalTime));continue;}break;}// Get next process from ready queue\nconst currentProcess=readyQueue.shift();// Set start time if first execution\nif(currentProcess.startTime===undefined){currentProcess.startTime=currentTime;currentProcess.responseTime=currentTime-currentProcess.arrivalTime;}// Calculate execution time for this quantum\nconst executionTime=Math.min(timeQuantum,currentProcess.remainingTime);// Add to Gantt chart\nganttChart.push({processId:currentProcess.id,startTime:currentTime,endTime:currentTime+executionTime,color:currentProcess.color});// Update remaining time and current time\ncurrentProcess.remainingTime-=executionTime;currentTime+=executionTime;// Check if process is completed\nif(currentProcess.remainingTime===0){currentProcess.completionTime=currentTime;currentProcess.turnaroundTime=currentProcess.completionTime-currentProcess.arrivalTime;currentProcess.waitingTime=currentProcess.turnaroundTime-currentProcess.burstTime;completedProcesses.push(currentProcess);}else{// Move arrived processes to ready queue before re-adding current process\nconst newlyArrived=processQueue.filter(p=>p.arrivalTime<=currentTime);readyQueue.push(...newlyArrived);processQueue.splice(0,newlyArrived.length);// Add process back to ready queue\nreadyQueue.push(currentProcess);}}// Calculate averages\nconst avgWaitingTime=completedProcesses.reduce((sum,p)=>sum+p.waitingTime,0)/processes.length;const avgTurnaroundTime=completedProcesses.reduce((sum,p)=>sum+p.turnaroundTime,0)/processes.length;const avgResponseTime=completedProcesses.reduce((sum,p)=>sum+p.responseTime,0)/processes.length;return{ganttChart,processes:completedProcesses,averageWaitingTime:avgWaitingTime,averageTurnaroundTime:avgTurnaroundTime,averageResponseTime:avgResponseTime};};","map":{"version":3,"names":["roundRobin","processes","timeQuantum","processQueue","map","p","_objectSpread","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","readyQueue","length","newlyArrived","filter","arrivalTime","push","splice","Math","min","currentProcess","shift","responseTime","executionTime","processId","id","endTime","color","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/roundRobin.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const roundRobin = (processes: Process[], timeQuantum: number): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let readyQueue: Process[] = [];\n\n    while (processQueue.length > 0 || readyQueue.length > 0) {\n        // Move arrived processes to ready queue\n        const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n        readyQueue.push(...newlyArrived);\n        processQueue.splice(0, newlyArrived.length);\n\n        if (readyQueue.length === 0) {\n            // No processes in ready queue, jump to next arrival\n            if (processQueue.length > 0) {\n                currentTime = Math.min(...processQueue.map(p => p.arrivalTime));\n                continue;\n            }\n            break;\n        }\n\n        // Get next process from ready queue\n        const currentProcess = readyQueue.shift()!;\n\n        // Set start time if first execution\n        if (currentProcess.startTime === undefined) {\n            currentProcess.startTime = currentTime;\n            currentProcess.responseTime = currentTime - currentProcess.arrivalTime;\n        }\n\n        // Calculate execution time for this quantum\n        const executionTime = Math.min(timeQuantum, currentProcess.remainingTime!);\n\n        // Add to Gantt chart\n        ganttChart.push({\n            processId: currentProcess.id,\n            startTime: currentTime,\n            endTime: currentTime + executionTime,\n            color: currentProcess.color\n        });\n\n        // Update remaining time and current time\n        currentProcess.remainingTime! -= executionTime;\n        currentTime += executionTime;\n\n        // Check if process is completed\n        if (currentProcess.remainingTime === 0) {\n            currentProcess.completionTime = currentTime;\n            currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;\n            currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;\n            completedProcesses.push(currentProcess);\n        } else {\n            // Move arrived processes to ready queue before re-adding current process\n            const newlyArrived = processQueue.filter(p => p.arrivalTime <= currentTime);\n            readyQueue.push(...newlyArrived);\n            processQueue.splice(0, newlyArrived.length);\n            \n            // Add process back to ready queue\n            readyQueue.push(currentProcess);\n        }\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}