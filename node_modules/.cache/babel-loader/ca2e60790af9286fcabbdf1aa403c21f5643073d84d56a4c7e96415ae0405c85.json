{"ast":null,"code":"export const srtf = processes => {\n  const processQueue = [...processes].map(p => ({\n    ...p,\n    remainingTime: p.burstTime,\n    startTime: undefined\n  }));\n  const ganttChart = [];\n  const completedProcesses = [];\n  let currentTime = 0;\n  let currentProcess = null;\n  let lastProcessId = null;\n  while (processQueue.length > 0 || currentProcess) {\n    // Add newly arrived processes\n    const arrivedProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n    // Find process with shortest remaining time\n    let shortestJob = currentProcess;\n    for (const process of arrivedProcesses) {\n      if (!shortestJob || process.remainingTime < shortestJob.remainingTime) {\n        shortestJob = process;\n      }\n    }\n\n    // Process context switch if needed\n    if (shortestJob && shortestJob.id !== lastProcessId) {\n      if (lastProcessId !== null) {\n        // Add previous process block to Gantt chart\n        const lastGanttBlock = ganttChart[ganttChart.length - 1];\n        if (lastGanttBlock) {\n          lastGanttBlock.endTime = currentTime;\n        }\n      }\n\n      // Start new process block\n      if (shortestJob.startTime === undefined) {\n        shortestJob.startTime = currentTime;\n        shortestJob.responseTime = currentTime - shortestJob.arrivalTime;\n      }\n      ganttChart.push({\n        processId: shortestJob.id,\n        startTime: currentTime,\n        endTime: currentTime + 1,\n        // Will be updated in next iteration\n        color: shortestJob.color\n      });\n    }\n\n    // Update current process and time\n    if (shortestJob) {\n      shortestJob.remainingTime--;\n      lastProcessId = shortestJob.id;\n\n      // Check if process is completed\n      if (shortestJob.remainingTime === 0) {\n        const processIndex = processQueue.findIndex(p => p.id === shortestJob.id);\n        if (processIndex !== -1) {\n          processQueue.splice(processIndex, 1);\n        }\n        shortestJob.completionTime = currentTime + 1;\n        shortestJob.turnaroundTime = shortestJob.completionTime - shortestJob.arrivalTime;\n        shortestJob.waitingTime = shortestJob.turnaroundTime - shortestJob.burstTime;\n        completedProcesses.push(shortestJob);\n        currentProcess = null;\n      } else {\n        currentProcess = shortestJob;\n      }\n    }\n    currentTime++;\n  }\n\n  // Update last Gantt chart block\n  if (ganttChart.length > 0) {\n    ganttChart[ganttChart.length - 1].endTime = currentTime;\n  }\n\n  // Calculate averages\n  const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;\n  const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;\n  const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime, 0) / processes.length;\n  return {\n    ganttChart,\n    processes: completedProcesses,\n    averageWaitingTime: avgWaitingTime,\n    averageTurnaroundTime: avgTurnaroundTime,\n    averageResponseTime: avgResponseTime\n  };\n};","map":{"version":3,"names":["srtf","processes","processQueue","map","p","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","currentProcess","lastProcessId","length","arrivedProcesses","filter","arrivalTime","shortestJob","process","id","lastGanttBlock","endTime","responseTime","push","processId","color","processIndex","findIndex","splice","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/srtf.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const srtf = (processes: Process[]): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let currentProcess: Process | null = null;\n    let lastProcessId: string | null = null;\n\n    while (processQueue.length > 0 || currentProcess) {\n        // Add newly arrived processes\n        const arrivedProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n        // Find process with shortest remaining time\n        let shortestJob: Process | null = currentProcess;\n        for (const process of arrivedProcesses) {\n            if (!shortestJob || process.remainingTime! < shortestJob.remainingTime!) {\n                shortestJob = process;\n            }\n        }\n\n        // Process context switch if needed\n        if (shortestJob && shortestJob.id !== lastProcessId) {\n            if (lastProcessId !== null) {\n                // Add previous process block to Gantt chart\n                const lastGanttBlock = ganttChart[ganttChart.length - 1];\n                if (lastGanttBlock) {\n                    lastGanttBlock.endTime = currentTime;\n                }\n            }\n\n            // Start new process block\n            if (shortestJob.startTime === undefined) {\n                shortestJob.startTime = currentTime;\n                shortestJob.responseTime = currentTime - shortestJob.arrivalTime;\n            }\n\n            ganttChart.push({\n                processId: shortestJob.id,\n                startTime: currentTime,\n                endTime: currentTime + 1, // Will be updated in next iteration\n                color: shortestJob.color\n            });\n        }\n\n        // Update current process and time\n        if (shortestJob) {\n            shortestJob.remainingTime!--;\n            lastProcessId = shortestJob.id;\n\n            // Check if process is completed\n            if (shortestJob.remainingTime === 0) {\n                const processIndex = processQueue.findIndex(p => p.id === shortestJob!.id);\n                if (processIndex !== -1) {\n                    processQueue.splice(processIndex, 1);\n                }\n\n                shortestJob.completionTime = currentTime + 1;\n                shortestJob.turnaroundTime = shortestJob.completionTime - shortestJob.arrivalTime;\n                shortestJob.waitingTime = shortestJob.turnaroundTime - shortestJob.burstTime;\n                completedProcesses.push(shortestJob);\n                currentProcess = null;\n            } else {\n                currentProcess = shortestJob;\n            }\n        }\n\n        currentTime++;\n    }\n\n    // Update last Gantt chart block\n    if (ganttChart.length > 0) {\n        ganttChart[ganttChart.length - 1].endTime = currentTime;\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}