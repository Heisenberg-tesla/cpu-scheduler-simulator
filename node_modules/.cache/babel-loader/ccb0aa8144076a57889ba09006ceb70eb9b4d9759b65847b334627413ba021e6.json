{"ast":null,"code":"import _objectSpread from\"C:/Users/ayush/OneDrive/Desktop/Job Scheduler/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";export const priority=(processes,isPreemptive)=>{const processQueue=[...processes].map(p=>_objectSpread(_objectSpread({},p),{},{remainingTime:p.burstTime,startTime:undefined}));const ganttChart=[];const completedProcesses=[];let currentTime=0;let currentProcess=null;let lastProcessId=null;while(processQueue.length>0||currentProcess){// Get available processes\nconst availableProcesses=processQueue.filter(p=>p.arrivalTime<=currentTime);// Find highest priority process\nlet highestPriorityProcess=currentProcess;for(const process of availableProcesses){if(!highestPriorityProcess||process.priority<highestPriorityProcess.priority||process.priority===highestPriorityProcess.priority&&process.arrivalTime<highestPriorityProcess.arrivalTime){if(isPreemptive||!currentProcess){highestPriorityProcess=process;}}}// Process context switch if needed\nif(highestPriorityProcess&&highestPriorityProcess.id!==lastProcessId){if(lastProcessId!==null){// Add previous process block to Gantt chart\nconst lastGanttBlock=ganttChart[ganttChart.length-1];if(lastGanttBlock){lastGanttBlock.endTime=currentTime;}}// Start new process block\nif(highestPriorityProcess.startTime===undefined){highestPriorityProcess.startTime=currentTime;highestPriorityProcess.responseTime=currentTime-highestPriorityProcess.arrivalTime;}ganttChart.push({processId:highestPriorityProcess.id,startTime:currentTime,endTime:currentTime+1,// Will be updated in next iteration\ncolor:highestPriorityProcess.color});}// Update current process and time\nif(highestPriorityProcess){highestPriorityProcess.remainingTime--;lastProcessId=highestPriorityProcess.id;// Check if process is completed\nif(highestPriorityProcess.remainingTime===0){const processIndex=processQueue.findIndex(p=>p.id===highestPriorityProcess.id);if(processIndex!==-1){processQueue.splice(processIndex,1);}highestPriorityProcess.completionTime=currentTime+1;highestPriorityProcess.turnaroundTime=highestPriorityProcess.completionTime-highestPriorityProcess.arrivalTime;highestPriorityProcess.waitingTime=highestPriorityProcess.turnaroundTime-highestPriorityProcess.burstTime;completedProcesses.push(highestPriorityProcess);currentProcess=null;}else{currentProcess=highestPriorityProcess;}}currentTime++;}// Update last Gantt chart block\nif(ganttChart.length>0){ganttChart[ganttChart.length-1].endTime=currentTime;}// Calculate averages\nconst avgWaitingTime=completedProcesses.reduce((sum,p)=>sum+p.waitingTime,0)/processes.length;const avgTurnaroundTime=completedProcesses.reduce((sum,p)=>sum+p.turnaroundTime,0)/processes.length;const avgResponseTime=completedProcesses.reduce((sum,p)=>sum+p.responseTime,0)/processes.length;return{ganttChart,processes:completedProcesses,averageWaitingTime:avgWaitingTime,averageTurnaroundTime:avgTurnaroundTime,averageResponseTime:avgResponseTime};};","map":{"version":3,"names":["priority","processes","isPreemptive","processQueue","map","p","_objectSpread","remainingTime","burstTime","startTime","undefined","ganttChart","completedProcesses","currentTime","currentProcess","lastProcessId","length","availableProcesses","filter","arrivalTime","highestPriorityProcess","process","id","lastGanttBlock","endTime","responseTime","push","processId","color","processIndex","findIndex","splice","completionTime","turnaroundTime","waitingTime","avgWaitingTime","reduce","sum","avgTurnaroundTime","avgResponseTime","averageWaitingTime","averageTurnaroundTime","averageResponseTime"],"sources":["C:/Users/ayush/OneDrive/Desktop/Job Scheduler/src/algorithms/priority.ts"],"sourcesContent":["import { Process, SchedulerResult, GanttChartBlock } from '../utils/types';\n\nexport const priority = (processes: Process[], isPreemptive: boolean): SchedulerResult => {\n    const processQueue = [...processes].map(p => ({ \n        ...p, \n        remainingTime: p.burstTime,\n        startTime: undefined\n    }));\n    const ganttChart: GanttChartBlock[] = [];\n    const completedProcesses: Process[] = [];\n    let currentTime = 0;\n    let currentProcess: Process | null = null;\n    let lastProcessId: string | null = null;\n\n    while (processQueue.length > 0 || currentProcess) {\n        // Get available processes\n        const availableProcesses = processQueue.filter(p => p.arrivalTime <= currentTime);\n\n        // Find highest priority process\n        let highestPriorityProcess: Process | null = currentProcess;\n        for (const process of availableProcesses) {\n            if (!highestPriorityProcess || \n                (process.priority! < highestPriorityProcess.priority!) || \n                (process.priority === highestPriorityProcess.priority && \n                 process.arrivalTime < highestPriorityProcess.arrivalTime)) {\n                if (isPreemptive || !currentProcess) {\n                    highestPriorityProcess = process;\n                }\n            }\n        }\n\n        // Process context switch if needed\n        if (highestPriorityProcess && highestPriorityProcess.id !== lastProcessId) {\n            if (lastProcessId !== null) {\n                // Add previous process block to Gantt chart\n                const lastGanttBlock = ganttChart[ganttChart.length - 1];\n                if (lastGanttBlock) {\n                    lastGanttBlock.endTime = currentTime;\n                }\n            }\n\n            // Start new process block\n            if (highestPriorityProcess.startTime === undefined) {\n                highestPriorityProcess.startTime = currentTime;\n                highestPriorityProcess.responseTime = currentTime - highestPriorityProcess.arrivalTime;\n            }\n\n            ganttChart.push({\n                processId: highestPriorityProcess.id,\n                startTime: currentTime,\n                endTime: currentTime + 1, // Will be updated in next iteration\n                color: highestPriorityProcess.color\n            });\n        }\n\n        // Update current process and time\n        if (highestPriorityProcess) {\n            highestPriorityProcess.remainingTime!--;\n            lastProcessId = highestPriorityProcess.id;\n\n            // Check if process is completed\n            if (highestPriorityProcess.remainingTime === 0) {\n                const processIndex = processQueue.findIndex(p => p.id === highestPriorityProcess!.id);\n                if (processIndex !== -1) {\n                    processQueue.splice(processIndex, 1);\n                }\n\n                highestPriorityProcess.completionTime = currentTime + 1;\n                highestPriorityProcess.turnaroundTime = highestPriorityProcess.completionTime - highestPriorityProcess.arrivalTime;\n                highestPriorityProcess.waitingTime = highestPriorityProcess.turnaroundTime - highestPriorityProcess.burstTime;\n                completedProcesses.push(highestPriorityProcess);\n                currentProcess = null;\n            } else {\n                currentProcess = highestPriorityProcess;\n            }\n        }\n\n        currentTime++;\n    }\n\n    // Update last Gantt chart block\n    if (ganttChart.length > 0) {\n        ganttChart[ganttChart.length - 1].endTime = currentTime;\n    }\n\n    // Calculate averages\n    const avgWaitingTime = completedProcesses.reduce((sum, p) => sum + p.waitingTime!, 0) / processes.length;\n    const avgTurnaroundTime = completedProcesses.reduce((sum, p) => sum + p.turnaroundTime!, 0) / processes.length;\n    const avgResponseTime = completedProcesses.reduce((sum, p) => sum + p.responseTime!, 0) / processes.length;\n\n    return {\n        ganttChart,\n        processes: completedProcesses,\n        averageWaitingTime: avgWaitingTime,\n        averageTurnaroundTime: avgTurnaroundTime,\n        averageResponseTime: avgResponseTime\n    };\n};\n"],"mappings":"kIAEA,MAAO,MAAM,CAAAA,QAAQ,CAAGA,CAACC,SAAoB,CAAEC,YAAqB,GAAsB,CACtF,KAAM,CAAAC,YAAY,CAAG,CAAC,GAAGF,SAAS,CAAC,CAACG,GAAG,CAACC,CAAC,EAAAC,aAAA,CAAAA,aAAA,IAClCD,CAAC,MACJE,aAAa,CAAEF,CAAC,CAACG,SAAS,CAC1BC,SAAS,CAAEC,SAAS,EACtB,CAAC,CACH,KAAM,CAAAC,UAA6B,CAAG,EAAE,CACxC,KAAM,CAAAC,kBAA6B,CAAG,EAAE,CACxC,GAAI,CAAAC,WAAW,CAAG,CAAC,CACnB,GAAI,CAAAC,cAA8B,CAAG,IAAI,CACzC,GAAI,CAAAC,aAA4B,CAAG,IAAI,CAEvC,MAAOZ,YAAY,CAACa,MAAM,CAAG,CAAC,EAAIF,cAAc,CAAE,CAC9C;AACA,KAAM,CAAAG,kBAAkB,CAAGd,YAAY,CAACe,MAAM,CAACb,CAAC,EAAIA,CAAC,CAACc,WAAW,EAAIN,WAAW,CAAC,CAEjF;AACA,GAAI,CAAAO,sBAAsC,CAAGN,cAAc,CAC3D,IAAK,KAAM,CAAAO,OAAO,GAAI,CAAAJ,kBAAkB,CAAE,CACtC,GAAI,CAACG,sBAAsB,EACtBC,OAAO,CAACrB,QAAQ,CAAIoB,sBAAsB,CAACpB,QAAU,EACrDqB,OAAO,CAACrB,QAAQ,GAAKoB,sBAAsB,CAACpB,QAAQ,EACpDqB,OAAO,CAACF,WAAW,CAAGC,sBAAsB,CAACD,WAAY,CAAE,CAC5D,GAAIjB,YAAY,EAAI,CAACY,cAAc,CAAE,CACjCM,sBAAsB,CAAGC,OAAO,CACpC,CACJ,CACJ,CAEA;AACA,GAAID,sBAAsB,EAAIA,sBAAsB,CAACE,EAAE,GAAKP,aAAa,CAAE,CACvE,GAAIA,aAAa,GAAK,IAAI,CAAE,CACxB;AACA,KAAM,CAAAQ,cAAc,CAAGZ,UAAU,CAACA,UAAU,CAACK,MAAM,CAAG,CAAC,CAAC,CACxD,GAAIO,cAAc,CAAE,CAChBA,cAAc,CAACC,OAAO,CAAGX,WAAW,CACxC,CACJ,CAEA;AACA,GAAIO,sBAAsB,CAACX,SAAS,GAAKC,SAAS,CAAE,CAChDU,sBAAsB,CAACX,SAAS,CAAGI,WAAW,CAC9CO,sBAAsB,CAACK,YAAY,CAAGZ,WAAW,CAAGO,sBAAsB,CAACD,WAAW,CAC1F,CAEAR,UAAU,CAACe,IAAI,CAAC,CACZC,SAAS,CAAEP,sBAAsB,CAACE,EAAE,CACpCb,SAAS,CAAEI,WAAW,CACtBW,OAAO,CAAEX,WAAW,CAAG,CAAC,CAAE;AAC1Be,KAAK,CAAER,sBAAsB,CAACQ,KAClC,CAAC,CAAC,CACN,CAEA;AACA,GAAIR,sBAAsB,CAAE,CACxBA,sBAAsB,CAACb,aAAa,EAAG,CACvCQ,aAAa,CAAGK,sBAAsB,CAACE,EAAE,CAEzC;AACA,GAAIF,sBAAsB,CAACb,aAAa,GAAK,CAAC,CAAE,CAC5C,KAAM,CAAAsB,YAAY,CAAG1B,YAAY,CAAC2B,SAAS,CAACzB,CAAC,EAAIA,CAAC,CAACiB,EAAE,GAAKF,sBAAsB,CAAEE,EAAE,CAAC,CACrF,GAAIO,YAAY,GAAK,CAAC,CAAC,CAAE,CACrB1B,YAAY,CAAC4B,MAAM,CAACF,YAAY,CAAE,CAAC,CAAC,CACxC,CAEAT,sBAAsB,CAACY,cAAc,CAAGnB,WAAW,CAAG,CAAC,CACvDO,sBAAsB,CAACa,cAAc,CAAGb,sBAAsB,CAACY,cAAc,CAAGZ,sBAAsB,CAACD,WAAW,CAClHC,sBAAsB,CAACc,WAAW,CAAGd,sBAAsB,CAACa,cAAc,CAAGb,sBAAsB,CAACZ,SAAS,CAC7GI,kBAAkB,CAACc,IAAI,CAACN,sBAAsB,CAAC,CAC/CN,cAAc,CAAG,IAAI,CACzB,CAAC,IAAM,CACHA,cAAc,CAAGM,sBAAsB,CAC3C,CACJ,CAEAP,WAAW,EAAE,CACjB,CAEA;AACA,GAAIF,UAAU,CAACK,MAAM,CAAG,CAAC,CAAE,CACvBL,UAAU,CAACA,UAAU,CAACK,MAAM,CAAG,CAAC,CAAC,CAACQ,OAAO,CAAGX,WAAW,CAC3D,CAEA;AACA,KAAM,CAAAsB,cAAc,CAAGvB,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAAC6B,WAAY,CAAE,CAAC,CAAC,CAAGjC,SAAS,CAACe,MAAM,CACxG,KAAM,CAAAsB,iBAAiB,CAAG1B,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAAC4B,cAAe,CAAE,CAAC,CAAC,CAAGhC,SAAS,CAACe,MAAM,CAC9G,KAAM,CAAAuB,eAAe,CAAG3B,kBAAkB,CAACwB,MAAM,CAAC,CAACC,GAAG,CAAEhC,CAAC,GAAKgC,GAAG,CAAGhC,CAAC,CAACoB,YAAa,CAAE,CAAC,CAAC,CAAGxB,SAAS,CAACe,MAAM,CAE1G,MAAO,CACHL,UAAU,CACVV,SAAS,CAAEW,kBAAkB,CAC7B4B,kBAAkB,CAAEL,cAAc,CAClCM,qBAAqB,CAAEH,iBAAiB,CACxCI,mBAAmB,CAAEH,eACzB,CAAC,CACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}